# Custom Auth System (Django + DRF + JWT + RBAC)

Это тестовое задание, реализующее бэкенд-систему с кастомной аутентификацией и авторизацией на основе ролей (RBAC). Проект не полагается только на стандартные группы/права Django, а использует собственную схему управления доступом.

## Стек технологий
*   Python 3.10+
*   Django 5.2
*   Django Rest Framework (DRF)
*   SimpleJWT (для работы с токенами)
*   PostgreSQL

---

## Схема управления ограничениями доступа (RBAC)

Система разграничения прав базируется на трёх основных сущностях: **Роль**, **Ресурс** и **Право Доступа**.

### 1. Роль (Role)
Определяет группу пользователей с одинаковыми привилегиями.
*   Пользователь (`User`) имеет ссылку на одну `Role`.
*   Примеры: `admin`, `manager`, `user`.

### 2. Ресурс (Resource)
Сущность или раздел системы, доступ к которому нужно контролировать. Это не обязательно модель БД, это может быть логический раздел API.
*   Привязывается к ViewSet/APIView через атрибут `resource_name`.
*   Примеры: `financial_reports` (финансовые отчеты), `users_list` (список пользователей), `settings` (настройки).

### 3. Права Доступа (RolePermission)
Связующая таблица, определяющая, **какие действия** конкретная **Роль** может выполнять над конкретным **Ресурсом**.
Матрица прав описывается 4-мя флагами (CRUD):
*   `can_create`: Разрешает POST запросы.
*   `can_read`: Разрешает GET запросы.
*   `can_update`: Разрешает PUT/PATCH запросы.
*   `can_delete`: Разрешает DELETE запросы.

### Алгоритм проверки (RbacPermission)
При каждом запросе к защищенному API срабатывает кастомный Permission Class:
1.  Проверяет, аутентифицирован ли пользователь.
2.  Определяет имя ресурса, к которому идет обращение (из атрибута `resource_name` во View).
3.  Находит роль текущего пользователя.
4.  Ищет запись в таблице `RolePermission` для пары (Роль пользователя, Запрашиваемый ресурс).
5.  Если запись найдена, проверяет флаг, соответствующий HTTP-методу (например, `GET` -> `can_read`).
6.  Если разрешено — доступ открыт, иначе — `403 Forbidden`.

---

## Установка и запуск

### 1. Клонирование и окружение
```bash
git clone <repo_url>
cd test-backend
python -m venv venv
# Windows
venv\Scripts\activate
# Linux/Mac
source venv/bin/activate
```

### 2. Зависимости
```bash
pip install -r requirements.txt
```

### 3. База данных (PostgreSQL)
Проект настроен на работу с локальным PostgreSQL или через Docker.
Если есть Docker:
```bash
docker-compose up -d
```

### 4. Миграции и инициализация
```bash
python manage.py migrate
# Создание базовых ролей (admin, user) и ресурсов
python manage.py init_data
# Создание суперпользователя (для админки Django, если нужно)
python manage.py createsuperuser
```

### 5. Запуск сервера
```bash
python manage.py runserver
```

---

## Тестирование API и RBAC

В проекте реализована команда для автоматической проверки сценариев доступа.
Она создает тестовых пользователей (админа и обычного юзера) и проверяет доступ к защищенному ресурсу `reports`.

```bash
python manage.py test_scenarios
```

Ожидаемый результат:
1.  **Anonymous**: 401 Unauthorized.
2.  **User (GET)**: 200 OK (Есть право на чтение).
3.  **User (POST)**: 403 Forbidden (Нет права на создание).
4.  **Admin (POST)**: 405 Method Not Allowed (Доступ от RBAC получен, но View не реализует POST).

## API Endpoints

*   `POST /api/auth/register/` - Регистрация
*   `POST /api/auth/login/` - Получение JWT токена
*   `GET /api/auth/me/` - Профиль текущего пользователя
*   `GET /api/reports/` - Пример защищенного ресурса (Финансовые отчеты)

### Управление правами (только для Admin)
*   `/api/roles/` - CRUD Ролей
*   `/api/rbac/resources/` - CRUD Ресурсов
*   `/api/rbac/permissions/` - Настройка матрицы доступа
